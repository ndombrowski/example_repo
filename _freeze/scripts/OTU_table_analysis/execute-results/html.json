{
  "hash": "d163735d4ff371b59c838470e6ca9a7e",
  "result": {
    "engine": "knitr",
    "markdown": "---\nformat:\n  html:\n    embed-resources: true\n    toc: true\n    toc-location: left\n    df-print: kable\n\nexecute:\n  eval: true\n\nengine: knitr\n---\n\n\n# Analysing 16S rRNA data with R\n\nThe goal of this tutorial is to analyse 16S rRNA gene data. Our input file is an OTU/ASV table that already contains some taxa information and will go through the following steps:\n\n- Reading the data into R\n- Filtering the data \n- Normalizing the data\n- Visualizing the data (i.e. alpha/beta diversity, barplots, ...)\n\nIn the example we look at an OTU table of 28 samples. These 28 samples represent three distinct microbiomes from three Winogradsky column experiments in which columns were created using wood, paper and a wood/paper mix as substrate. DNA was collected on two separate dates, so another category we can compare is the sampling date.\n\n\n## Setup\n\nWe start with setting a path to working directory and setting a seed seed for normalization protocol. \n\nSetting a set is not essential but this way we make sure that we get the same results when normalizing our OTU table. If we randomly select some observations for any task in R or in any statistical software it results in different values all the time and this happens because of randomization. If we want to keep the values that are produced at first random selection then we can do this by storing them in an object after randomization or we can fix the randomization procedure so that we get the same results all the time.\n\n\n## Installation notes\n\nSome packages required for this workflow are installed with BiocManager or devtools, if you need to install any of these tools, remove the `#` from the code and run it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#if (!require(\"BiocManager\", quietly = TRUE))\n#    install.packages(\"BiocManager\")\n\n#BiocManager::install(\"phyloseq\")\n#BiocManager::install(\"microbiome\")\n#BiocManager::install(\"ALDEx2\")\n#BiocManager::install(\"DESeq2\")\n```\n:::\n\n\n\n## Load packages\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse) #general parsing\nlibrary(data.table) #general parsing\nlibrary(phyloseq) #phyloseq object loading\nlibrary(vegan) #rarefaction\nlibrary(microbiome) #normalization\nlibrary(ALDEx2) #stats\nlibrary(DESeq2) #stats\nlibrary(grid) #organizing multiple plots\nlibrary(gridExtra) #organizing multiple plots\nlibrary(scales) #plot aesthetic, comma setting\nlibrary(ANCOMBC) #stats\nlibrary(ggvenn) # vendiagram\nlibrary(gplots) #vendiagram\n```\n:::\n\n\n\n## Custom functions\n\nNext, we read in some custom things such as a theme that we will use for plotting our graphs and a color vectors.\n\nDefining a custom_theme for our plots is useful because it means that instead of re-writing the commands for our plot over and over again in each plot, we can just use the `custom_theme` function instead.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#define custom theme for generating figures\ncustom_theme <- function() {\n  theme(\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.background = element_blank(), \n    panel.border =element_blank(),\n    axis.line.x = element_line(color=\"black\", size = 0.5),\n    axis.line.y = element_line(color=\"black\", size = 0.5),\n    strip.text.x = element_text(size = 7),\n    strip.text.y = element_text(size = 7),\n    strip.background = element_rect(fil=\"#FFFFFF\", color = \"black\", linewidth = 0.5),\n    axis.text.x = element_text(size = 7),\n    legend.text = element_text(size = 8), legend.title = element_text(size = 10)\n  )\n}\n\n#generate color scheme \nc25 <- c(\"dodgerblue2\", \"#E31A1C\", \"green4\", \"#6A3D9A\", \"#FF7F00\", \"black\", \"gold1\", \"skyblue2\", \"#FB9A99\", \n        \"palegreen2\", \"#CAB2D6\", \"#FDBF6F\", \"gray70\", \"khaki2\", \"maroon\", \"orchid1\", \"deeppink1\", \"blue1\", \n        \"steelblue4\", \"darkturquoise\", \"green1\", \"yellow4\", \"yellow3\",\"darkorange4\", \"brown\")\n```\n:::\n\n\n\n\n## Read in the data\n\n### OTU table\n\nAn OTU table contains a column with the OTUs (taxonomic ranks in our case) and one column per sample with the counts how often OTU is found in the sample. It might look something like this:\n\n|#NAME|EP1910|RMT|KJB3|TJR|\n|:----|:----|:----|:----|:----|\n|Bacteria;Acidobacteria;Acidobacteriia;Acidobacteriales;Acidobacteriaceae (Subgroup 1);NA|0|0|0|0|\n|Bacteria;Acidobacteria;Acidobacteriia;Solibacterales;Solibacteraceae (Subgroup 3);PAUC26f|0|5|3|1|\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Provide the path to the otu table\nfile_paths <- c(\"../data/for_ma/otu-table-forMA.txt\")\n\n# Read in otu table\nmerged_otu_table <- read.table(file_paths, header = T, sep = '\\t', comment = \"\")\ncolnames(merged_otu_table)[1] <- \"taxid\"\n\n# Replace NA with 0\nmerged_otu_table[is.na(merged_otu_table)] <- 0\n\n# R does not like - and will replace things with dots, clean up the sample names\ncolnames(merged_otu_table) <- gsub(\"\\\\.\", \"_\", colnames(merged_otu_table)) \n\n#use the taxon as rownames\nrownames(merged_otu_table) <- merged_otu_table$taxid\nmerged_otu_table$taxid <- NULL\n\n#check how many otus and samples we have\ndim(merged_otu_table)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1248   20\n```\n\n\n:::\n:::\n\n\nWith this example OTU table, we work with `dim(merged_otu_table)[2]` samples and 1248 OTUs.\n\n\n\n\n### Metadata \n\nThe metadata table contains information about our samples and can look something like this:\n\n|#NAME|treatment|Date|\n|:----|:----|:----|\n|EP1910|wood|2023_1|\n|RMT|paper|2023_1|\n|KJB3|mix|2023_1|\n|TJR|paper|2023_1|\n|IB5|wood|2023_1|\n|ALIDNA|wood|2023_1|\n|IG7|paper|2023_1|\n|B314|mix|2023_1|\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Read in metadata file\nmetadata_combined <- read.table(\"../data/for_ma/sample_table.txt\", header = TRUE, row.names = 1, sep = \"\\t\", comment.char = \"\")\n\n# Replace dashes with underscores in row names\nrownames(metadata_combined) <- gsub(\"-\", \"_\", rownames(metadata_combined))\n\n# Ensure that the group data is categorical \nmetadata_combined$Practical_group <- gsub(\"^\", \"Day\", metadata_combined$Practical_group)\n\n# Add extra column for sample names\nmetadata_combined$name <- paste0(metadata_combined$Carbon_source, \"_\", rownames(metadata_combined))\nmetadata_combined$sample_id <- rownames(metadata_combined)\n\n# Order the factors for our names column\nmetadata_combined <- metadata_combined |> \n  arrange(desc(Carbon_source))\n\n# View output\nhead(metadata_combined)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|        |Barcode |Carbon_source |Wino_Column |Practical_group |name         |sample_id |\n|:-------|:-------|:-------------|:-----------|:---------------|:------------|:---------|\n|EP_SD1  |BC10    |wood          |SD1         |Day1            |wood_EP_SD1  |EP_SD1    |\n|RK_SD1  |BC12    |wood          |SD1         |Day1            |wood_RK_SD1  |RK_SD1    |\n|EW_SD1  |BC23    |wood          |SD1         |Day2            |wood_EW_SD1  |EW_SD1    |\n|DG_SD1  |BC24    |wood          |SD1         |Day2            |wood_DG_SD1  |DG_SD1    |\n|AW_SD2  |BC05    |wood          |SD2         |Day2            |wood_AW_SD2  |AW_SD2    |\n|UNZ_SD2 |BC06    |wood          |SD2         |Day2            |wood_UNZ_SD2 |UNZ_SD2   |\n\n</div>\n:::\n:::\n\n\n\n\n\n## Generate taxonomy file\n\nNext, we generate a table that list the taxonomy information for each taxonomic rank. We do this by taking the information from our OTU table. Depending on how you analysed your 16S rRNA gene sequences, you might have an OTU table with IDs (ASV1, ASV2, ... or OTU1, OTU2, ...) and a separate table with the taxonomy information. \n\nIf that is the case, you can read in the taxonomy information separate.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#extract taxonomy string\ntemp <- as.data.frame(rownames(merged_otu_table))\ncolnames(temp) <- \"OTU\"\n\n#separate the taxonomic headers                      \ntaxonomy_file <- temp |> \n  distinct(OTU) |> \n  separate(OTU,\n           c(\"Kingdom\", \"Phylum\", \"Class\", \"Order\", \"Family\", \"Genus\"), \n           sep = \";\", remove = FALSE) |> \n  column_to_rownames(var = \"OTU\")\n\n#view file\nhead(taxonomy_file)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|                                                                                              |Kingdom  |Phylum           |Class          |Order             |Family             |Genus           |\n|:---------------------------------------------------------------------------------------------|:--------|:----------------|:--------------|:-----------------|:------------------|:---------------|\n|Bacteria;10bav-F6;NA;NA;NA;NA                                                                 |Bacteria |10bav-F6         |NA             |NA                |NA                 |NA              |\n|Bacteria;Abditibacteriota;Abditibacteria;Abditibacteriales;Abditibacteriaceae;Abditibacterium |Bacteria |Abditibacteriota |Abditibacteria |Abditibacteriales |Abditibacteriaceae |Abditibacterium |\n|Bacteria;Acetothermia;Acetothermiia;NA;NA;NA                                                  |Bacteria |Acetothermia     |Acetothermiia  |NA                |NA                 |NA              |\n|Bacteria;Acidobacteriota;Acidobacteriae;AKIW659;NA;NA                                         |Bacteria |Acidobacteriota  |Acidobacteriae |AKIW659           |NA                 |NA              |\n|Bacteria;Acidobacteriota;Acidobacteriae;Bryobacterales;Bryobacteraceae;Bryobacter             |Bacteria |Acidobacteriota  |Acidobacteriae |Bryobacterales    |Bryobacteraceae    |Bryobacter      |\n|Bacteria;Acidobacteriota;Acidobacteriae;PAUC26f;NA;NA                                         |Bacteria |Acidobacteriota  |Acidobacteriae |PAUC26f           |NA                 |NA              |\n\n</div>\n:::\n:::\n\n\n## Generate phyloseq object\n\nA phyloseq object combines different elements of an analysis (i.e. the OTU table, the list of taxa and the mapping file) into one single object. We can easily generate such an object with the three dataframes we have generated above:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#combine data\nOTU = otu_table(merged_otu_table, taxa_are_rows = TRUE)\nTAX = tax_table(as.matrix(taxonomy_file))\nphyseq = phyloseq(OTU, TAX, sample_data(metadata_combined))\n\n#view structure\nphyseq\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nphyloseq-class experiment-level object\notu_table()   OTU Table:         [ 1248 taxa and 20 samples ]\nsample_data() Sample Data:       [ 20 samples by 6 sample variables ]\ntax_table()   Taxonomy Table:    [ 1248 taxa by 6 taxonomic ranks ]\n```\n\n\n:::\n:::\n\n\n\n\n## Exploring the raw data\n\n### Get some summary statistics\n\nBelow, we write a custom function to calculate some summary statistics. We easily could do this without a function, however, since we want to compare the statistics before and after  filtering the OTU table, the function is useful to have, since we do not need to copy-paste the exact same code in two spots of the workflow:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint_summary <- function(reads_per_OTU) {\n  total_reads <- sum(reads_per_OTU)\n  otu_number <- length(reads_per_OTU)\n  num_singletons <- length(reads_per_OTU[reads_per_OTU == 1])\n  num_doubletons <- length(reads_per_OTU[reads_per_OTU == 2])\n  num_less_than_10 <- length(reads_per_OTU[reads_per_OTU < 10])\n  total_reads_less_than_10 <- sum(reads_per_OTU[reads_per_OTU < 10])\n  perc_reads_less_than_10 <- (total_reads_less_than_10 / sum(reads_per_OTU)) * 100\n  \n  cat(\"Total number of reads:\", format(total_reads, big.mark = \",\"), \"\\n\")\n  cat(\"Number of OTUs\",  format(otu_number, big.mark = \",\"), \"\\n\")\n  cat(\"Number of singleton OTUs:\",  format(num_singletons, big.mark = \",\"), \"\\n\")\n  cat(\"Number of doubleton OTUs:\",  format(num_doubletons, big.mark = \",\"), \"\\n\")\n  cat(\"Number of OTUs with less than 10 seqs:\",  format(num_less_than_10, big.mark = \",\"), \"\\n\")\n  cat(\"Total reads for OTUs with less than 10 seqs:\",  format(total_reads_less_than_10, big.mark = \",\"), \"\\n\")\n  cat(\"Percentage of reads for OTUs with less than 10 seqs:\",  sprintf(\"%.2f%%\", perc_reads_less_than_10), \"\\n\")\n  \n}\n\n#calculate the number of reads found per otu\nreads_per_OTU <- taxa_sums(physeq)\n\n#summarize the data\nprint_summary(reads_per_OTU)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTotal number of reads: 366,981 \nNumber of OTUs 1,248 \nNumber of singleton OTUs: 245 \nNumber of doubleton OTUs: 95 \nNumber of OTUs with less than 10 seqs: 609 \nTotal reads for OTUs with less than 10 seqs: 1,728 \nPercentage of reads for OTUs with less than 10 seqs: 0.47% \n```\n\n\n:::\n:::\n\nFor this workflow, we define *singletons** as reads/OTUs with a sequence that is present exactly once in the dataset.\n\nNotice that another definition of singletons can be as taxa/OTU present in a single sample.\n        \nIn amplicon data analysis it is useful to remove reads with low counts because they are very likely due to sequencing errors. We generally assume that sequencing errors are independent and randomly distributed, and we can assume that erroneous sequences will occur much less often than the true sequence. We will remove such sequences during the data filtering step.\n\n\n### Explore the sequencing depth\n\nNext, let's explore how many reads we have per sample:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#count the number of reads per sample\nsample_counts <- as.data.frame(colSums(merged_otu_table))\n                  \n#clean up the dataframe\nnames(sample_counts)[1] <- \"counts\"\nsample_counts$sampleID <- rownames(sample_counts)\n\n#plot counts\np_counts <-\n  ggplot(data = sample_counts, aes(x = reorder(sampleID, counts, FUN=sum, decreasing = TRUE), y = counts)) +\n  geom_point() +\n  geom_text(aes(x = , sampleID, y = counts, label = counts),  hjust = 0, nudge_y = 200 , size = 2.5) +\n  coord_flip() +\n  xlab(\"\") + \n  ylab(\"Read counts\") +\n  custom_theme()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: The `size` argument of `element_line()` is deprecated as of ggplot2 3.4.0.\nℹ Please use the `linewidth` argument instead.\n```\n\n\n:::\n\n```{.r .cell-code}\np_counts\n```\n\n::: {.cell-output-display}\n![](OTU_table_analysis_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nIn this example, we see two samples with almost no reads and we want to make sure to remove these samples. We also see that we have a large difference between different samples. To be able to compare for example sample IV (~25,000 reads) with sample MN (~1,000 reads) we need to normalize our data after the data filtering step.\n\n\n\n## Filter data\n\nNext, we filter the data. Specifically, we:\n\n- Remove OTUs that are not assigned to anything at Phylum rank. The `subset_taxa` function can be used to remove any taxa you want, i.e. if you have plant DNA in your sample, you could use this to remove chloroplast sequences as well.  \n- Remove samples with total read counts less than 20. This cutoff is arbitrary and depends a bit on your data. To choose a good value, explore the read counts you have per sample and define a cutoff based on that. In this example, we mainly want to remove the two low read samples we have seen in our plot.  \n- Remove low count OTUs: The threshold is up to you; removing singletons or doubletons is common, but you can be more conservative and remove any counts less than 10. Look at the plots before and get a feeling for how many OTUs were removed.  \n\nIn our example, we want to remove samples with 20 or less reads, remove singletons only and remove OTUs that occur in less than 10% of our samples (v1). Since there are many different thoughts about OTU table filtering, you can also find two other options (v2 and v3) on how to filter a table.\n\nFor most analyses we will work with the filtered data but there are some diversity metrics which rely on the presence of singletons within a sample (richness estimates, i.e. Chao), so you might choose to leave them in for those sorts of analyses only. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n#define cutoffs\ncounts_per_sample <- 20\notu_nr_cutoff <- 1\nmin_percentage_samples <- 10\n\n#remove taxa without tax assignment at Phylum rank\nphyseq_filt <- subset_taxa(physeq, Phylum != \"NA\")\n\n#remove samples with less than 20 reads\nphyseq_filt <- prune_samples(sample_sums(physeq)>= counts_per_sample, physeq)\n\n#calculate the minimum number of samples an otu should be present in\nmin_samples <- ceiling((min_percentage_samples / 100) * nsamples(physeq_filt))\n\n#remove otus that occur only rarely (v1)\n#here, we calculate the total abundance of each otu across all samples and checks if it's greater than the specified otu_nr_cutoff AND we check if the otu occurs in at least <min_percentage_samples>% of samples\n#we only retain OTUs that satisfy this condition \nphyseq_filt <- prune_taxa(taxa_sums(physeq_filt) > otu_nr_cutoff & taxa_sums(physeq_filt) >= min_samples, physeq_filt)\nphyseq_filt\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nphyloseq-class experiment-level object\notu_table()   OTU Table:         [ 989 taxa and 19 samples ]\nsample_data() Sample Data:       [ 19 samples by 6 sample variables ]\ntax_table()   Taxonomy Table:    [ 989 taxa by 6 taxonomic ranks ]\n```\n\n\n:::\n\n```{.r .cell-code}\n#remove otus that occur only rarely (v2)\n#here, we count the number of samples where the abundance of an otu is > 0. \n#If this count is greater than the specified otu_nr_cutoff, the taxon is retained.\n#physeq_filt <- filter_taxa(physeq, function (x) {sum(x > 0) > otu_nr_cutoff}, prune=TRUE)\n#physeq_filt\n\n#remove otus that occur only rarely (v3)\n#here, we remove taxa not seen more than 1 times in at least 10% of the samples\n#physeq_filt = filter_taxa(physeq, function(x) sum(x > 1) > (0.1*length(x)), TRUE)\n#physeq_filt\n```\n:::\n\nNext, we can calculate the summary statistics with the custom `taxa_sums` function we have defined before:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#calculate the number of reads found per otu\nreads_per_OTU_filt <- taxa_sums(physeq_filt)\n\n#summarize the data\nprint_summary(reads_per_OTU_filt)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTotal number of reads: 366,733 \nNumber of OTUs 989 \nNumber of singleton OTUs: 0 \nNumber of doubleton OTUs: 95 \nNumber of OTUs with less than 10 seqs: 350 \nTotal reads for OTUs with less than 10 seqs: 1,483 \nPercentage of reads for OTUs with less than 10 seqs: 0.40% \n```\n\n\n:::\n:::\n\n\n\n\n## Normalize data\n\nBelow, we generate three new phyloseq objects using three different normalization approaches:\n1. Compositional: transforms the data into relative abundance\n2. CLR: stands for centerd log-ratio transform and allows us to compare proportions of OTUs within each sample. After this transformation the values will no longer be counts, but rather the dominance (or lack thereof) for each taxa relative to the geometric mean of all taxa on the logarithmic scale\n3. Rarefaction: scales all of your reads down to the lowest total sequencing depth. Notice, that this might drop many OTUs in higher read samples and might lead to under-estimation of low-abundant OTUs\n\nGenerating different phyloseq objects for different normalization approaches allows us to easily compare analysis steps with different inputs. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nphyseq_rel_abundance <- microbiome::transform(physeq_filt, \"compositional\")\nphyseq_clr <- microbiome::transform(physeq_filt, \"clr\")\nphyseq_rarified <- rarefy_even_depth(physeq_filt)\n```\n:::\n\n\n\n## Data exploration\n\n### Rarefaction\n\nRarefactions illustrate how well your sample was sampled. The rarefaction function takes a random subsample of each column in your OTU table of a given size, starting with a very small subsample, and counts how many unique OTUs were observed in that subsample. The analysis is repeated with increasing subsample sizes until the maximum actual read depth for your table is reached. \n\nIn an ideal dataset, each curve should reach a plateau, i.e. horizontal asymptote, ideally around the same depth. While this almost never is the case, exploring these graphs gives us an idea how well each sample was sampled.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#create a df from our otu table\ndf <- as.data.frame(otu_table(physeq_filt))\n\n#rarefy data with a step size of 50, using tidy = TRUE will return a dataframe instead of a plot\ndf_rate <- rarecurve(t(df), step=50, cex=0.5, label = FALSE, tidy = TRUE)\n\n#add metadata\ndf_rate <- merge(df_rate, metadata_combined, by.x = \"Site\", by.y = \"sample_id\")\n\n#plot\ndf_rate %>%\n  group_by(Site) %>%\n  mutate(max_sample = max(Sample)) %>%\n  mutate(label = if_else(Sample == max_sample, as.character(Site), NA_character_)) %>%\n  ggplot(aes(x = Sample, y = Species, color = Carbon_source, group = interaction(Site, Carbon_source))) + \n  geom_line() + \n  facet_grid(cols = vars(Carbon_source)) +\n  geom_text(aes(label = label),\n            position = position_nudge(x = 2000),\n            na.rm = TRUE, size = 3) +\n  custom_theme()\n```\n\n::: {.cell-output-display}\n![](OTU_table_analysis_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\nIn this example we can see that almost none of the sample reach a plateau, RH is the closest but not there yet. This suggests that we mainly sampled the abundant members of our community and might miss many rare taxa. This is something to keep in mind for other analyses, such as alpha diversity analyses.\n\n\n\n### Alpha diversity\n\nAlpha diversity measures the diversity within our sample and we distinguish between species richness (i.e. the number of species) and species richness (i.e. how relatively abundant each of the species are). \n\n\n::: {.cell}\n\n```{.r .cell-code}\n#calculate different alpha diversity indicators\nrichness_meta <-microbiome::alpha(physeq_filt, index = \"all\")\n\n#add the sample id to table\nrichness_meta$sample_id <- rownames(richness_meta)\n\n#add other metadata data\nrichness_meta  <- merge(richness_meta, metadata_combined, by = \"sample_id\")\n\n#check what parameters are calculated\ncolnames(richness_meta)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"sample_id\"                  \"observed\"                  \n [3] \"chao1\"                      \"diversity_inverse_simpson\" \n [5] \"diversity_gini_simpson\"     \"diversity_shannon\"         \n [7] \"diversity_fisher\"           \"diversity_coverage\"        \n [9] \"evenness_camargo\"           \"evenness_pielou\"           \n[11] \"evenness_simpson\"           \"evenness_evar\"             \n[13] \"evenness_bulla\"             \"dominance_dbp\"             \n[15] \"dominance_dmn\"              \"dominance_absolute\"        \n[17] \"dominance_relative\"         \"dominance_simpson\"         \n[19] \"dominance_core_abundance\"   \"dominance_gini\"            \n[21] \"rarity_log_modulo_skewness\" \"rarity_low_abundance\"      \n[23] \"rarity_rare_abundance\"      \"Barcode\"                   \n[25] \"Carbon_source\"              \"Wino_Column\"               \n[27] \"Practical_group\"            \"name\"                      \n```\n\n\n:::\n:::\n\n\nNext, we can generate a plot. Since we calculated the diversity estimates after removing singletons, we will look at evenness indices, such as the Shannon index.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#generate figure\nalpha_plot <-\n  ggplot(richness_meta, aes(x = Carbon_source, y = chao1)) +\n    geom_boxplot() +\n    geom_jitter(aes(color = Practical_group), width = 0.2, size = 4) +\n    labs(x = \"\", y = \"Chao1 index\") +\n    custom_theme() +\n    theme(axis.title.y = element_text(size = 20),\n          axis.text.x = element_text(size = 20),\n          axis.text.y = element_text(size = 14),\n          legend.key=element_blank(), \n          legend.text = element_text(size=14),\n          legend.title = element_text(size=20)\n          ) \n\nalpha_plot\n```\n\n::: {.cell-output-display}\n![](OTU_table_analysis_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n\n```{.r .cell-code}\n#save the figure to our computer\n#ggsave(paste0(\"results/plots/alpha-div.png\"), plot=alpha_plot, device=\"png\")\n```\n:::\n\nWe see that there is not a difference in terms of species evenness when comparing our different samples.\n\n\n\n\n### Beta diversity\n\nIn contrast to alpha diversity, beta diversity quantifies the dissimilarity between communities (multiple samples).\n\nCommonly used metrics include:\n- the Bray-Curtis index (for compositional/abundance data)\n- Jaccard index (for presence/absence data, ignoring abundance information)\n- Aitchison distance (Euclidean distance for clr transformed abundances, aiming to avoid the compositionality bias)\n- Unifrac distance (that takes into account the phylogenetic tree information)\n- ...\n\nAvoid methods that use Euclidean distance as microbiome data are sparse datasets and better suited for the above mentioned methods.\n\nBased on the type of algorithm, ordination methods can be divided in two categories: \n- unsupervised, which measure variation in the data without additional information on covariates or other supervision of the model, including:\n  - Principal Coordinate Analysis (PCoA)\n  - Principal Component Analysis (PCA) \n  - Uniform Manifold Approximation and Projection for Dimension Reduction (UMAP)\n- supervised ordination:\n  - distance-based Redundancy Analysis (dbRDA)\n\n\n#### Bray-Curtis\n\nFor Bray-Curtis our data should not have negative entries, so we will use the relative abundance (or rarefied) data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#convert otu table to df\ndata_otu_filt_rar <- t(data.frame(otu_table(physeq_rarified)))\n\n#calculate bray-curtis \ndist_bc <- as.matrix(vegdist(data_otu_filt_rar, method = \"bray\")) \n\n# calculate PCOA using Phyloseq package\npcoa_bc <- ordinate(physeq_rarified, \"PCoA\", \"bray\") \n\nplot_ordination(physeq_rarified, pcoa_bc, color = \"Carbon_source\", shape = \"Practical_group\") + \n  geom_point(size = 3) +\n  custom_theme()\n```\n\n::: {.cell-output-display}\n![](OTU_table_analysis_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\nFirst, this two-dimensions PCOA plot show 34% of the total variance between the samples. Next, we see that the our samples are not forming distinct clusters, i.e. microbiomes from the mixed, paper and wood communities appear very similar.\n\nNext, we can do a statistical test:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#extract metdatatas\nmetadata2 <- data.frame(meta(physeq_rarified))\n  \n# Permanova test using the vegan package\nadonis2(data_otu_filt_rar~Carbon_source, data = metadata2, permutations=9999, method=\"bray\")\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|              | Df|  SumOfSqs|        R2|        F| Pr(>F)|\n|:-------------|--:|---------:|---------:|--------:|------:|\n|Carbon_source |  1| 0.6906827| 0.2075976| 4.453746| 0.0025|\n|Residual      | 17| 2.6363440| 0.7924024|       NA|     NA|\n|Total         | 18| 3.3270267| 1.0000000|       NA|     NA|\n\n</div>\n:::\n:::\n\n\nThis confirms that there do not seem to be any statistically significant differences between our samples.\n\n\n### Aitchison\n\nNext, we generate a beta-diversity ordination using the Aitchison distance. We do this by applying PCA to the centered log-ratio (CLR) transformed counts.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#PCA via phyloseq\n#RDA without constraints is a PCA\nord_clr <- phyloseq::ordinate(physeq_clr, \"RDA\", distance = \"euclidian\")\n\n#Plot scree plot to plot eigenvalues, i.e.the total amount of variance that can be explained by a given principal componen\nphyloseq::plot_scree(ord_clr) + \n  geom_bar(stat=\"identity\", fill = \"blue\") +\n  custom_theme() +\n  labs(x = \"\\nAxis\", y = \"Proportion of Variance\\n\")\n```\n\n::: {.cell-output-display}\n![](OTU_table_analysis_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#Scale axes\nclr1 <- ord_clr$CA$eig[1] / sum(ord_clr$CA$eig)\nclr2 <- ord_clr$CA$eig[2] / sum(ord_clr$CA$eig)\n\n#and plot\nphyloseq::plot_ordination(physeq_clr, ord_clr, color = \"Carbon_source\", shape = \"Practical_group\") + \n  geom_point(size = 2,) +\n  coord_fixed(clr2 / clr1) +\n  stat_ellipse(aes(group = Carbon_source), linetype = 2) +\n  custom_theme() \n```\n\n::: {.cell-output-display}\n![](OTU_table_analysis_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n\nWhile PCA is an exploratory data visualization tool, we can test whether the samples cluster beyond that expected by sampling variability using permutational multivariate analysis of variance (PERMANOVA). It does this by partitioning the sums of squares for the within- and between-cluster components using the concept of centroids. Many permutations of the data (i.e. random shuffling) are used to generate the null distribution. The test from ADONIS can be confounded by differences in dispersion (or spread)…so we want to check this as well. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Generate distance matrix\nclr_dist_matrix <- phyloseq::distance(physeq_clr, method = \"euclidean\") \n\n#ADONIS test\nadonis2(clr_dist_matrix~Carbon_source, data = metadata2, permutations=9999, method=\"bray\")\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|              | Df|  SumOfSqs|       R2|        F| Pr(>F)|\n|:-------------|--:|---------:|--------:|--------:|------:|\n|Carbon_source |  1|  6379.877| 0.183901| 3.830806|  4e-04|\n|Residual      | 17| 28312.034| 0.816099|       NA|     NA|\n|Total         | 18| 34691.911| 1.000000|       NA|     NA|\n\n</div>\n:::\n:::\n\n\n\n\n### Taxonomic distribution\n\nNext, we want to plot the taxa distribution. Let us first look at the most abundant phyla and check how similar our different samples are:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#condense data at specific tax rank, i.e. on phylum level\ngrouped_taxa <- tax_glom(physeq_rel_abundance, \"Phylum\")\n  \n#find top19 most abundant taxa \ntop_taxa <- names(sort(taxa_sums(grouped_taxa), TRUE)[1:19])\n\n#make a list for the remaining taxa\nother_taxa <- names(taxa_sums(grouped_taxa))[which(!names(taxa_sums(grouped_taxa)) %in% top_taxa)]\n\n#group the low abundant taxa into one group\nmerged_physeq = merge_taxa(grouped_taxa, other_taxa, 2)\n  \n#transform phyloseq object into dataframe\ndf <- psmelt(merged_physeq)\n\n#cleanup the names in the df\nnames(df)[names(df) == \"Phylum\"] <- \"tax_level\"\n\n#replace NAs, with other (NAs are generated for the other category)\ndf$tax_level[which(is.na(df$tax_level))] <- \"Other\"\n  \n#create a df to sort taxa labels by abundance\nsorted_labels <- df |> \n  group_by(tax_level) |> \n  summarise(sum = sum(Abundance)) |> \n  arrange(desc(sum))\n  \n#Get list of sorted levels excluding \"Other\"\ndesired_levels <- setdiff(sorted_labels$tax_level, \"Other\")\n  \n#sort df using the sorted levels and ensure that \"Other\" is the last category\ndf$tax_level2 <- factor(df$tax_level, levels = c(desired_levels, \"Other\"))\n  \n#generate color scheme\ncols <- c25[1:length(unique(df$tax_level2))]\ncols[levels(df$tax_level2) == \"Other\"] <- \"#CCCCCC\"\n  \n#plot\nfig <-\n  ggplot(df, aes(x = Sample, y = Abundance, fill = tax_level2) ) +\n    geom_bar(position = \"stack\", stat = \"identity\", width = 0.9) +\n    labs(y = \"Relative abundance\", x = \"\", title = paste0(\"Relative abundance at \", \"Phylum\", \" rank\")) +\n    scale_fill_manual(name = paste0(\"Phylum\",\"_rank\"), labels = levels(df$tax_level2), values = cols) +\n    facet_grid(cols =  vars(Carbon_source), scales = \"free\", space = \"free\") +\n    scale_y_continuous(expand = c(0, 0), limits = c(0, 1.01)) +\n    custom_theme() +\n    theme(axis.text.x = element_text(angle = 45, hjust = 1 ) ) +\n    guides(fill=guide_legend(title = \"Phylum\"))\n\nfig\n```\n\n::: {.cell-output-display}\n![](OTU_table_analysis_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\nSince we want to generate one plot for each taxonomic rank, i.e. Phylum, Class, Order,..., we can do this in a loop. The figures will be generated in the folder `results/plots/`. \n\nIf you do not feel comfortable with a lob, you can also do this step by step by removing the for statement and replacing all instances of `level` with the taxonomic rank you want to investigate\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#if not there already, create output folder\nimg_path=\"../results/r_analyses/images/\"\ndir.create(img_path, recursive = TRUE)\n\n#generate one barplot for each taxonomic level\nfor (level in colnames(taxonomy_file)){\n  \n  #condense data at specific tax rank, i.e. on phylum level\n  grouped_taxa <- tax_glom(physeq_rel_abundance, level)\n  \n  #find top19 most abundant taxa \n  top_taxa <- names(sort(taxa_sums(grouped_taxa), TRUE)[1:19])\n  \n  #make a list for the remaining taxa\n  other_taxa <- names(taxa_sums(grouped_taxa))[which(!names(taxa_sums(grouped_taxa)) %in% top_taxa)]\n  \n  #group the low abundant taxa into one group\n  merged_physeq = merge_taxa(grouped_taxa, other_taxa, 2)\n  \n  #transform phyloseq object into dataframe\n  df <- psmelt(merged_physeq) \n  \n  #cleanup the dataframe\n  names(df)[names(df) == level] <- \"tax_level\"\n  df$tax_level[which(is.na(df$tax_level))] <- \"Other\"\n  \n  #create a df to sort taxa labels by abundance\n  sorted_labels <- df |> \n    group_by(tax_level) |> \n    summarise(sum = sum(Abundance)) |> \n    arrange(desc(sum))\n  \n  #Get list of sorted levels excluding \"Other\"\n  desired_levels <- setdiff(sorted_labels$tax_level, \"Other\")\n  \n  #sort df using the sorted levels and ensure that \"Other\" is the last category\n  df$tax_level2 <- factor(df$tax_level, levels = c(desired_levels, \"Other\"))\n  \n  #generate color scheme\n  cols <- c25[1:length(unique(df$tax_level2))]\n  cols[levels(df$tax_level2) == \"Other\"] <- \"#CCCCCC\"\n  \n  #plot\n  fig <-\n    ggplot(df, aes(x = Sample, y = Abundance, fill = tax_level2) ) +\n      geom_bar(position = \"stack\", stat = \"identity\", width = 0.9) +\n      labs(y = \"Relative abundance\", x = \"\", title = paste0(\"Relative abundance at \", level, \" rank\")) +\n      scale_fill_manual(name = paste0(level,\"_rank\"), labels = levels(df$tax_level2), values = cols) +\n      facet_grid(cols =  vars(Carbon_source), scales = \"free\", space = \"free\") +\n      scale_y_continuous(expand = c(0, 0), limits = c(0, 1.01)) +\n      custom_theme() +\n      theme(axis.text.x = element_text(angle = 45, hjust = 1 ) ) +\n      guides(fill=guide_legend(title=level))\n  \n  ggsave(paste0(img_path, level, \"_barplot_ra.png\"), plot = fig, device=\"png\")\n  }\n```\n:::\n\n\nGenerated plots:\n\n::: {layout-ncol=2}\n![](../results/r_analyses/images/Phylum_barplot_ra.png)\n![](../results/r_analyses/images/Order_barplot_ra.png)\n\n![](../results/r_analyses/images/Class_barplot_ra.png)\n![](../results/r_analyses/images/Family_barplot_ra.png)\n:::\n\n\n\n### Differential abundance testing\n\nNotice: This is still in development and needs to be optimized, use with care!\n\n\n\n#### Two-factor testing\n\nFirst, let us compare for differences for a category where we compare two factors. For example, we might want to ask whether there are any significant differences when comparing our wood versus paper samples.\n\nLet's first tes test this using the non-parametric Wilcoxon rank-sum test.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Generate data.frame with OTUs and metadata\nps_wilcox <- data.frame(t(data.frame(phyloseq::otu_table(physeq_clr))), check.names = FALSE)\nps_wilcox$Carbon_source <- phyloseq::sample_data(physeq_clr)$Carbon_source\n\n#Define functions to pass to map\nwilcox_model <- function(df){\n  wilcox.test(abund ~ Carbon_source, data = df)\n}\n\nwilcox_pval <- function(df){\n  wilcox.test(abund ~ Carbon_source, data = df)$p.value\n}\n\n#Create nested data frames by OTU and loop over each using map \nwilcox_results <- ps_wilcox %>%\n  gather(key = OTU, value = abund, -Carbon_source) %>%\n  group_by(OTU) %>%\n  nest() %>%\n  mutate(wilcox_test = map(data, wilcox_model),\n         p_value = map(data, wilcox_pval))  \n\n#Show results\nwilcox_results$wilcox_test[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tWilcoxon rank sum exact test\n\ndata:  abund by Carbon_source\nW = 44, p-value = 1\nalternative hypothesis: true location shift is not equal to 0\n```\n\n\n:::\n:::\n\n\n\nWe can also test for differences per OTU:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Unnesting\nwilcox_results <- wilcox_results %>%\n  dplyr::select(OTU, p_value) %>%\n  unnest(cols = c(p_value))\n\nhead(wilcox_results)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|OTU                                                                                           |   p_value|\n|:---------------------------------------------------------------------------------------------|---------:|\n|Bacteria;10bav-F6;NA;NA;NA;NA                                                                 | 1.0000000|\n|Bacteria;Abditibacteriota;Abditibacteria;Abditibacteriales;Abditibacteriaceae;Abditibacterium | 0.9038925|\n|Bacteria;Acetothermia;Acetothermiia;NA;NA;NA                                                  | 0.0120664|\n|Bacteria;Acidobacteriota;Acidobacteriae;Bryobacterales;Bryobacteraceae;Bryobacter             | 0.2375433|\n|Bacteria;Acidobacteriota;Acidobacteriae;PAUC26f;NA;NA                                         | 0.0754148|\n|Bacteria;Acidobacteriota;Acidobacteriae;TSBb06;NA;NA                                          | 0.0068006|\n\n</div>\n:::\n\n```{.r .cell-code}\n#Computing FDR corrected p-values (since we do multiple statistical comparisons)\nwilcox_results <- wilcox_results %>%\n  arrange(p_value) %>%\n  mutate(BH_FDR = p.adjust(p_value, \"BH\")) %>%\n  filter(BH_FDR < 0.001) %>%\n  dplyr::select(OTU, p_value, BH_FDR, everything())\n\nhead(wilcox_results)  \n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|OTU                                                                                     |  p_value|   BH_FDR|\n|:---------------------------------------------------------------------------------------|--------:|--------:|\n|Bacteria;Bacteroidota;Bacteroidia;Bacteroidales;Ika33;NA                                | 2.65e-05| 2.65e-05|\n|Bacteria;Firmicutes;Clostridia;Eubacteriales;Alkalibacteraceae;Alkalibacter             | 2.65e-05| 2.65e-05|\n|Bacteria;Firmicutes;Clostridia;Oscillospirales;Hungateiclostridiaceae;Acetivibrio       | 2.65e-05| 2.65e-05|\n|Bacteria;Firmicutes;Clostridia;Oscillospirales;Hungateiclostridiaceae;Ruminiclostridium | 2.65e-05| 2.65e-05|\n|Bacteria;Firmicutes;Clostridia;Peptostreptococcales-Tissierellales;NA;JTB215            | 2.65e-05| 2.65e-05|\n|Bacteria;Verrucomicrobiota;Lentisphaeria;Oligosphaerales;Lenti-02;NA                    | 2.65e-05| 2.65e-05|\n\n</div>\n:::\n:::\n\n\nWilcoxon has some down-sites when it comes to treating zero values, an alternative approach is to use the ANOVA-like differential expression (ALDEx2) method. The aldex function is a wrapper that performs log-ratio transformation and statistical testing in a single line of code, which is why we feed the non-normalized data into it:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naldex2_da <- ALDEx2::aldex(data.frame(phyloseq::otu_table(physeq_filt)), phyloseq::sample_data(physeq_filt)$Carbon_source, test=\"t\", effect = TRUE, denom=\"iqlr\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\naldex.clr: generating Monte-Carlo instances and clr values\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\noperating in serial mode\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\ncomputing iqlr centering\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\naldex.ttest: doing t-test\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\naldex.effect: calculating effect sizes\n```\n\n\n:::\n:::\n\n\nSpecifically, this function: \n\n(a) generates Monte Carlo samples of the Dirichlet distribution for each sample, \n(b) converts each instance using a log-ratio transform,  \n(c) returns test results for two sample (Welch's t, Wilcoxon) or multi-sample (glm, Kruskal-Wallace) tests.\n\niqlr\" accounts for data with systematic variation and centers the features on the set features that have variance that is between the lower and upper quartile of variance. This provides results that are more robust to asymmetric features between groups.\n\nNext, we can plot the effect size. The effect size plot shows the median log2 fold difference by the median log2 dispersion. This is a measure of the effect size by the variability. Differentially abundant taxon will be those where the difference most exceeds the dispersion. Points toward the top of the figure are more abundant in CF samples while those towards the bottom are more abundant in healthy controls. Taxa with BH-FDR corrected p-values are shown in red. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n#plot effect sizes\nALDEx2::aldex.plot(aldex2_da, type=\"MW\", test=\"wilcox\", called.cex = 1, cutoff.pval = 0.001)\n```\n\n::: {.cell-output-display}\n![](OTU_table_analysis_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\nFinally, we can print the output with the taxa information added.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Clean up presentation\nsig_aldex2 <- aldex2_da %>%\n  rownames_to_column(var = \"OTU\") %>%\n  filter(wi.eBH < 0.05) %>%\n  arrange(effect, wi.eBH) %>%\n  dplyr::select(OTU, diff.btw, diff.win, effect, wi.ep, wi.eBH)\n\nhead(sig_aldex2)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|OTU                                                                                     |  diff.btw|  diff.win|    effect|     wi.ep|    wi.eBH|\n|:---------------------------------------------------------------------------------------|---------:|---------:|---------:|---------:|---------:|\n|Bacteria;Firmicutes;Clostridia;Oscillospirales;Hungateiclostridiaceae;Ruminiclostridium | -7.603371| 2.1386233| -3.540289| 0.0000265| 0.0049666|\n|Bacteria;Firmicutes;Clostridia;Oscillospirales;Hungateiclostridiaceae;Acetivibrio       | -9.397042| 3.2100297| -2.922520| 0.0000265| 0.0049666|\n|Bacteria;Firmicutes;Clostridia;Peptostreptococcales-Tissierellales;NA;JTB215            | -2.130290| 0.9848773| -2.024687| 0.0000376| 0.0055734|\n|Bacteria;SAR324 clade(Marine group B);NA;NA;NA;NA                                       | -2.565471| 1.1989183| -2.016483| 0.0001385| 0.0102657|\n|Bacteria;Verrucomicrobiota;Lentisphaeria;Oligosphaerales;Lenti-02;NA                    | -2.327235| 1.2450759| -1.902249| 0.0000920| 0.0072225|\n|Bacteria;Firmicutes;Clostridia;Oscillospirales;Hungateiclostridiaceae;uncultured        | -2.139205| 1.1714844| -1.793109| 0.0000761| 0.0071607|\n\n</div>\n:::\n:::\n\n\nIn our case an empty dataframe is returned, no significant differences were detected.\n\n\n#### DESeq2\n\nDESeq2 performs a differential expression analysis based on the Negative Binomial (a.k.a. Gamma-Poisson) distribution. DeSeq normalizes the data throughout its analysis, so we input only the filtered data. For more theory, visit this [page](https://uclouvain-cbio.github.io/WSBIM2122/sec-rnaseq.html).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#convert treatment column to a factor\nsample_data(physeq_filt)$Carbon_source <- as.factor(sample_data(physeq_filt)$Carbon_source)\n\n#Convert the phyloseq object to a DESeqDataSet and run DESeq2:\nds <- phyloseq_to_deseq2(physeq_filt, ~ Carbon_source)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nconverting counts to integer mode\n```\n\n\n:::\n\n```{.r .cell-code}\n#since our samples contain a lot of 0s (something DeSeq is NOT designed for) we use some alternative means to estimate the size factor\nds <-estimateSizeFactors(ds, type = 'poscounts')\nds <- DESeq(ds)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nusing pre-existing size factors\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nestimating dispersions\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\ngene-wise dispersion estimates\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nmean-dispersion relationship\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nfinal dispersion estimates\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nfitting model and testing\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n-- replacing outliers and refitting for 56 genes\n-- DESeq argument 'minReplicatesForReplace' = 7 \n-- original counts are preserved in counts(dds)\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nestimating dispersions\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nfitting model and testing\n```\n\n\n:::\n\n```{.r .cell-code}\n#extract the results and filter by a FDR cutoff of 0.01 and\n#find significantly differentially abundant OTU between the seasons “paper” and “wood”\nalpha = 0.001\nres_desq = results(ds, contrast=c(\"Carbon_source\", \"paper\", \"wood\"), alpha=alpha)\nres_desq = res_desq[order(res_desq$padj, na.last=NA), ]\nres_sig_deseq = as.data.frame(res_desq[(res_desq$padj < alpha), ])\n\n#print number of significant results\ndim(res_sig_deseq)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 39  6\n```\n\n\n:::\n:::\n\n\n\nPlot significant OTUs (counts):\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- cbind(as.data.frame(as(tax_table(physeq_filt)[rownames(res_sig_deseq), ], \"matrix\")),as.data.frame(as(otu_table(physeq_filt)[rownames(res_sig_deseq), ], \"matrix\")))\n\ndf_long <- reshape2::melt(df)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nUsing Kingdom, Phylum, Class, Order, Family, Genus as id variables\n```\n\n\n:::\n\n```{.r .cell-code}\ndf_long <- merge(df_long, metadata2, by.x = \"variable\", by.y = \"sample_id\")\n\nggplot(df_long, aes(x=Genus, y=value, color = Carbon_source)) +\n  geom_boxplot(outlier.shape = NA) +\n  geom_point(position = position_jitterdodge(jitter.width=0.1), size = 0.9)  +\n  custom_theme() +\n  scale_color_manual(values = c( \"orange\", \"purple\")) +\n  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))\n```\n\n::: {.cell-output-display}\n![](OTU_table_analysis_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- cbind(as.data.frame(as(tax_table(physeq_rel_abundance)[rownames(res_sig_deseq), ], \"matrix\")),as.data.frame(as(otu_table(physeq_rel_abundance)[rownames(res_sig_deseq), ], \"matrix\")))\n\ndf_long <- reshape2::melt(df)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nUsing Kingdom, Phylum, Class, Order, Family, Genus as id variables\n```\n\n\n:::\n\n```{.r .cell-code}\ndf_long <- merge(df_long, metadata2, by.x = \"variable\", by.y = \"sample_id\")\n\nggplot(df_long, aes(x=Genus, y=value, color = Carbon_source)) +\n  geom_boxplot(outlier.shape = NA) +\n  geom_point(position = position_jitterdodge(jitter.width=0.1), size = 0.9)  +\n  custom_theme() +\n  scale_color_manual(values = c(\"orange\", \"purple\")) +\n  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))\n```\n\n::: {.cell-output-display}\n![](OTU_table_analysis_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n\n\n\n\n#### ANCOM\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Run ancom-bc2\n# Settings:\n# prv_cut: a numerical fraction between 0 and 1. Taxa with prevalences less than prv_cut will be excluded in the analysis\n# a numerical threshold for filtering samples based on library sizes. Samples with library sizes less than lib_cut\nancom_out = ancombc2(data = physeq_filt,\n               fix_formula = \"Carbon_source\",\n               rand_formula = NULL,\n               p_adj_method = \"holm\", \n               pseudo_sens = FALSE,  #FALSE to speed things up for testing, but makes things less sensitive\n               prv_cut = 0.10, lib_cut = 1000, s0_perc = 0.05,\n               group = \"Carbon_source\",\n               alpha = 0.05, n_cl = 2, verbose = TRUE,\n               global = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`tax_level` is not speficified \nNo agglomeration will be performed\nOtherwise, please speficy `tax_level` by one of the following: \nKingdom, Phylum, Class, Order, Family, Genus\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: The group variable has < 3 categories \nThe multi-group comparisons (global/pairwise/dunnet/trend) will be deactivated\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nObtaining initial estimates ...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nEstimating sample-specific biases ...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nANCOM-BC2 primary results ...\n```\n\n\n:::\n\n```{.r .cell-code}\nres_ancom = ancom_out$res\n\nres_f_fig = res_ancom %>%\n    dplyr::filter(diff_Carbon_sourcewood == TRUE) %>% \n    dplyr::arrange(desc(lfc_Carbon_sourcewood)) %>%\n    dplyr::mutate(direct = ifelse(lfc_Carbon_sourcewood > 0, \"Positive LFC\", \"Negative LFC\"),\n                  color = ifelse(lfc_Carbon_sourcewood > 0, \"aquamarine3\", \"black\"))\n\nres_f_fig$taxon = factor(res_f_fig$taxon, levels = res_f_fig$taxon)\nres_f_fig$direct = factor(res_f_fig$direct, \n                           levels = c(\"Positive LFC\", \"Negative LFC\"))\n\nfig_ancom = res_f_fig %>%\n    ggplot(aes(x = lfc_Carbon_sourcewood, y = taxon, fill = direct)) + \n    geom_bar(stat = \"identity\", width = 0.7, color = \"black\", \n             position = position_dodge(width = 0.4)) +\n    geom_errorbar(aes(xmin = lfc_Carbon_sourcewood - se_Carbon_sourcewood, xmax = lfc_Carbon_sourcewood + se_Carbon_sourcewood), \n                  width = 0.2, position = position_dodge(0.05), color = \"black\") + \n    labs(y = NULL, x = \"Log fold change Wood versus carbon\", \n         title = \"Log fold changes\") + \n    scale_fill_discrete(name = NULL) +\n    scale_color_discrete(name = NULL) +\n    custom_theme() + \n    theme(plot.title = element_text(hjust = 0.5),\n          panel.grid.minor.y = element_blank(),\n          axis.text.y = element_text(size=6))\nfig_ancom\n```\n\n::: {.cell-output-display}\n![](OTU_table_analysis_files/figure-html/unnamed-chunk-31-1.png){width=672}\n:::\n:::\n\n\n#### Vendiagram\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(\n  ancom = as.character(res_f_fig$taxon), \n  deseq = as.character(rownames(res_sig_deseq)), \n  wilcox = as.character(wilcox_results$OTU),\n  aldex = sig_aldex2$OTU\n  )\n\nggvenn(\n  x, \n  fill_color = c(\"#0073C2FF\", \"#EFC000FF\", \"#868686FF\", \"#CD534CFF\"),\n  stroke_size = 0.5, set_name_size = 4\n  )\n```\n\n::: {.cell-output-display}\n![](OTU_table_analysis_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Get intersection\nv_table <- venn(x, show.plot=FALSE)\nintersections<-attr(v_table,\"intersections\")\nsig_otus_ven <- intersections$`ancom:deseq:wilcox:aldex`\n\n# Plot\ndf <- cbind(as.data.frame(as(tax_table(physeq_filt)[sig_otus_ven, ], \"matrix\")),as.data.frame(as(otu_table(physeq_filt)[sig_otus_ven, ], \"matrix\")))\n\ndf_long <- reshape2::melt(df)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nUsing Kingdom, Phylum, Class, Order, Family, Genus as id variables\n```\n\n\n:::\n\n```{.r .cell-code}\ndf_long <- merge(df_long, metadata2, by.x = \"variable\", by.y = \"sample_id\")\n\nggplot(df_long, aes(x=Genus, y=value, color = Carbon_source)) +\n  geom_boxplot(outlier.shape = NA) +\n  geom_point(position = position_jitterdodge(jitter.width=0.1), size = 0.9)  +\n  custom_theme() +\n   facet_wrap(~Genus, scales = \"free\") +\n  scale_color_manual(values = c( \"orange\", \"purple\")) +\n  theme(axis.text.x = element_text())\n```\n\n::: {.cell-output-display}\n![](OTU_table_analysis_files/figure-html/unnamed-chunk-32-2.png){width=672}\n:::\n:::\n",
    "supporting": [
      "OTU_table_analysis_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}